package net.ent.entstupidstuff.world.tree;

import java.util.List;
import java.util.function.BiConsumer;

import com.google.common.collect.ImmutableList;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;

import net.ent.entstupidstuff.world.ConfiguredFeaturesFactory;
import net.minecraft.block.BlockState;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.random.Random;
import net.minecraft.world.TestableWorld;
import net.minecraft.world.gen.feature.TreeFeatureConfig;
import net.minecraft.world.gen.foliage.FoliagePlacer;
import net.minecraft.world.gen.trunk.TrunkPlacer;
import net.minecraft.world.gen.trunk.TrunkPlacerType;

public class ThreexThreeTrunkPlacer extends TrunkPlacer {
    public static final MapCodec<ThreexThreeTrunkPlacer> CODEC = RecordCodecBuilder.mapCodec(
		instance -> fillTrunkPlacerFields(instance).apply(instance, ThreexThreeTrunkPlacer::new)
	);

	public ThreexThreeTrunkPlacer(int i, int j, int k) {
		super(i, j, k);
	}

	@Override
	protected TrunkPlacerType<?> getType() {
		return ConfiguredFeaturesFactory.THREE_BY_THREE_TRUNK;
	}

	@Override
public List<FoliagePlacer.TreeNode> generate(
    TestableWorld world, BiConsumer<BlockPos, BlockState> replacer, Random random,
    int height, BlockPos startPos, TreeFeatureConfig config
) {
    // 1) Prep 3×3 dirt under the trunk, anchored at the CORNER (startPos)
    for (int dx = 0; dx < 3; dx++) {
        for (int dz = 0; dz < 3; dz++) {
            setToDirt(world, replacer, random, startPos.add(dx, -1, dz), config);
        }
    }

    // 2) Build a full 3×3 shaft for the entire height
    /*BlockPos.Mutable mutable = new BlockPos.Mutable();
    for (int y = 0; y < height; y++) {
        for (int dx = 0; dx < 3; dx++) {
            for (int dz = 0; dz < 3; dz++) {
                this.setLog(world, replacer, random, mutable, config, startPos, dx, y, dz);
            }
        }
    }*/

    BlockPos.Mutable mutable = new BlockPos.Mutable();
    for (int y = 0; y < height; y++) {
        int remaining = height - y;

        if (remaining > height / 4) {
            // Bottom 3/4 of the tree: full 3×3
            for (int dx = 0; dx < 3; dx++) {
                for (int dz = 0; dz < 3; dz++) {
                    this.setLog(world, replacer, random, mutable, config, startPos, dx, y, dz);
                }
            }
        } else if (remaining > height / 8) {
            // Next section: 3×3 but remove corners (rounded trunk)
            for (int dx = 0; dx < 3; dx++) {
                for (int dz = 0; dz < 3; dz++) {
                    if (!(dx == 0 && dz == 0) && !(dx == 0 && dz == 2)
                        && !(dx == 2 && dz == 0) && !(dx == 2 && dz == 2)) {
                        this.setLog(world, replacer, random, mutable, config, startPos, dx, y, dz);
                    }
                }
            }
        } else {
            // Very top: 2×2 core
            for (int dx = 1; dx <= 2; dx++) {
                for (int dz = 1; dz <= 2; dz++) {
                    this.setLog(world, replacer, random, mutable, config, startPos, dx - 1, y, dz - 1);
                }
            }
        }
    }

    // 3) Foliage from the CENTER of the 3×3
    BlockPos topCenter = startPos.add(1, height, 1);
    return ImmutableList.of(new FoliagePlacer.TreeNode(topCenter, 0, true));
}

	private void setLog(
		TestableWorld world,
		BiConsumer<BlockPos, BlockState> replacer,
		Random random,
		BlockPos.Mutable tmpPos,
		TreeFeatureConfig config,
		BlockPos startPos,
		int dx,
		int dy,
		int dz
	) {
		tmpPos.set(startPos, dx, dy, dz);
		this.trySetState(world, replacer, random, tmpPos, config);
	}
}
